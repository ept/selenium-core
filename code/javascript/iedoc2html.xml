<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:strip-space elements="*"/><xsl:output method="html"/>

<xsl:template match="/">
	<xsl:call-template name="header" />
	<xsl:apply-templates select="//top" />
	<xsl:call-template name="actionsHeader" />
	<dl>
	<xsl:apply-templates select="//function[not(return) and not(starts-with(@name, 'assert'))]" mode="action"/>
	</dl>
	<xsl:call-template name="assertionsHeader" />
	<dl>
	<xsl:apply-templates select="//function[starts-with(@name, 'assert')]" mode="action"/>
	<xsl:apply-templates select="//function[return]" mode="check"/>
	</dl>
	<xsl:call-template name="footer" />
</xsl:template>

<xsl:template name="assertionsHeader">
	<h3>Selenium Assertions</h3>
	<p>Assertions are used to verify the state of the application. They can be used to check the value of a form field, the presense of some text, or the URL of the current page.</p>
	<p>All Selenium assertions can be used in 2 modes, &quot;assert&quot; and &quot;verify&quot;. These behave identically, except that when an &quot;assert&quot; fails, the test is aborted. When a &quot;verify&quot; fails, the test will continue execution.  This allows a single &quot;assert&quot; to ensure that the application is on the correct page, followed by a bunch of &quot;verify&quot; assertions to test form field values, labels, etc.</p>
	
	<p>A growing number of assertions have a negative version.  In most cases, except where indicated, if the positive assertion is of the form <strong>assertXYZ</strong>, then the negative cases will be of the form <strong>assertNotXYZ</strong>.</p>
</xsl:template>

<xsl:template name="actionsHeader">
	<h3>Selenium Actions</h3>
	<p>Actions tell Selenium to do something in the application. They generally represent something a user would do.</p>
	<p>Many <strong>Actions</strong> can be called with the &quot;AndWait&quot; suffix.
	This suffix tells Selenium that the action will cause the browser to make a call to the server,
	and that Selenium should wait for a new page to load.</p>
	<p>Many Actions have a &quot;waitFor&quot; prefix.
	These commands wait for some condition to become true (can be useful for testing Ajax applications).
	They will succeed immediately if the condition is already true.
	However, they may also hang indefinitely if the conidition never becomes true.</p>
</xsl:template>

<xsl:template name="header">
	<h3>Selenium Reference</h3>
	<p>A <strong>command</strong> is what tells Selenium what to do. Selenium commands come in two 'flavors', <strong>Actions</strong> and <strong>Assertions</strong>.
	Each command call is one line in the test table of the form:</p>
	<blockquote>
	<table border="1" class="table">
	<colgroup>
	<col width="39%" />
	<col width="33%" />
	<col width="28%" />
	</colgroup>
	<tbody valign="top">
	<tr><td>command</td>
	<td>target</td>
	<td>value</td>
	</tr>
	</tbody>
	</table>
	</blockquote>
	<p><strong>Actions</strong> are commands that generally manipulate the state of the application. They do things like &quot;click this link&quot; and &quot;select that option&quot;. If an Action fails, or has an error, the execution of the current test is stopped.</p>
	<p><strong>Assertions</strong> verify the state of the application conforms to what is expected. Examples include &quot;make sure the page title is X&quot; and &quot;verify that this checkbox is checked&quot;. It is possible to tell Selenium to stop the test when an Assertion fails, or to simply record the failure and continue.</p>
	<p><strong>Element Locators</strong> tell Selenium which HTML element a command refers to. Many commands require an Element Locator as the &quot;target&quot; attribute. Examples of Element Locators include &quot;elementId&quot; and &quot;document.forms[0].element&quot;. These are described more clearly in the next section.</p>
	<p><strong>Patterns</strong> are used for various reasons, e.g. to specify the expected value of an input field, or identify a select option.  Selenium supports various types of pattern, including regular-expressions, all of which are described in more detail below.</p>
</xsl:template>

<xsl:template name="footer">
	<h3><a name="parameter-construction-and-variables">Parameter construction and Variables</a></h3>
	<blockquote>
	<p>All Selenium command parameters can be constructed using both simple
	variable substitution as well as full javascript. Both of these
	mechanisms can access previously stored variables, but do so using
	different syntax.</p>
	<p><strong>Stored Variables</strong></p>
	<p>The commands <em>store</em>, <em>storeValue</em> and <em>storeText</em> can be used to store a variable
	value for later access. Internally, these variables are stored in a map called &quot;storedVars&quot;,
	with values keyed by the variable name. These commands are documented in the command reference.</p>
	<p><strong>Variable substitution</strong></p>
	<p>Variable substitution provides a simple way to include a previously stored variable in a
	command parameter. This is a simple mechanism, by which the variable to substitute is indicated
	by ${variableName}. Multiple variables can be substituted, and intermixed with static text.</p>
	<p>Example:</p>
	<blockquote>
	<table border="1" class="table">
	<colgroup>
	<col width="18%" />
	<col width="36%" />
	<col width="45%" />
	</colgroup>
	<tbody valign="top">
	<tr><td>store</td>
	<td>Mr</td>
	<td>title</td>
	</tr>
	<tr><td>storeValue</td>
	<td>nameField</td>
	<td>surname</td>
	</tr>
	<tr><td>store</td>
	<td>${title} ${surname}</td>
	<td>fullname</td>
	</tr>
	<tr><td>type</td>
	<td>textElement</td>
	<td>Full name is: ${fullname}</td>
	</tr>
	</tbody>
	</table>
	</blockquote>
	<p><strong>Javascript evaluation</strong></p>
	<p>Javascript evaluation provides the full power of javascript in constructing a command parameter.
	To use this mechanism, the <em>entire</em> parameter value must be prefixed by
	'javascript{' with a trailing '}'. The text inside the braces is evaluated as a javascript expression,
	and can access previously stored variables using the <em>storedVars</em> map detailed above.
	Note that variable substitution cannot be combined with javascript evaluation.</p>
	<p>Example:</p>
	<blockquote>
	<table border="1" class="table">
	<colgroup>
	<col width="9%" />
	<col width="44%" />
	<col width="46%" />
	</colgroup>
	<tbody valign="top">
	<tr><td>store</td>
	<td>javascript{'merchant' + (new Date()).getTime()}</td>
	<td>merchantId</td>
	</tr>
	<tr><td>type</td>
	<td>textElement</td>
	<td>javascript{storedVars['merchantId'].toUpperCase()}</td>
	</tr>
	</tbody>
	</table>
	</blockquote>
	</blockquote>
	
	<div class="section" id="extending-selenium">
	<h1><a name="extending-selenium">Extending Selenium</a></h1>
	<blockquote>
	<p>It can be quite simple to extend Selenium, adding your own actions, assertions and locator-strategies.
	This is done with javascript by adding methods to the Selenium object prototype, and the PageBot
	object prototype. On startup, Selenium will automatically look through methods on these prototypes,
	using name patterns to recognise which ones are actions, assertions and locators.</p>
	<p>The following examples try to give an indication of how Selenium can be extended with javascript.</p>
	</blockquote>
	<p><strong>Actions</strong></p>
	<blockquote>
	<p>All <em>doFoo</em> methods on the Selenium prototype are added as actions. For each action <em>foo</em> there
	is also an action <em>fooAndWait</em> registered. An action method can take up to 2 parameters, which
	will be passed the second and third column values in the test.</p>
	<p>Example: Add a &quot;typeRepeated&quot; action to Selenium, which types the text twice into a text box.</p>
	<pre class="literal-block">
	Selenium.prototype.doTypeRepeated = function(locator, text) {
	    // All locator-strategies are automatically handled by &quot;findElement&quot;
	    var element = this.page().findElement(locator);
	
	    // Create the text to type
	    var valueToType = text + text;
	
	    // Replace the element text with the new text
	    this.page().replaceText(element, valueToType);
	};
	</pre>
	</blockquote>
	<p><strong>Assertions</strong></p>
	<blockquote>
	<p>All <em>assertFoo</em> methods on the Selenium prototype are added as assertions. For each assertion <em>foo</em> there
	is an <em>assertFoo</em> and <em>verifyFoo</em> registered. An assert method can take up to 2 parameters, which
	will be passed the second and third column values in the test.</p>
	<p>Example: Add a <em>valueRepeated</em> assertion, that makes sure that the element value
	consists of the supplied text repeated. The 2 commands that would be available in tests would be
	<em>assertValueRepeated</em> and <em>verifyValueRepeated</em>.</p>
	<pre class="literal-block">
	Selenium.prototype.assertValueRepeated = function(locator, text) {
	    // All locator-strategies are automatically handled by &quot;findElement&quot;
	    var element = this.page().findElement(locator);
	
	    // Create the text to verify
	    var expectedValue = text + text;
	
	    // Get the actual element value
	    var actualValue = element.value;
	
	    // Make sure the actual value matches the expected
	    Assert.matches(expectedValue, actualValue);
	};
	</pre>
	</blockquote>
	<p><strong>Locator Strategies</strong></p>
	<blockquote>
	<p>All <em>locateElementByFoo</em> methods on the PageBot prototype are added as locator-strategies. A locator strategy takes 2 parameters, the first being the locator string (minus the prefix), and the second being the document in which to search.</p>
	<p>Example: Add a &quot;valuerepeated=&quot; locator, that finds the first element a value attribute equal to the the supplied value repeated.</p>
	<pre class="literal-block">
	// The &quot;inDocument&quot; is a the document you are searching.
	PageBot.prototype.locateElementByValueRepeated = function(text, inDocument) {
	    // Create the text to search for
	    var expectedValue = text + text;
	
	    // Loop through all elements, looking for ones that have 
	    // a value === our expected value
	    var allElements = inDocument.getElementsByTagName(&quot;*&quot;);
	    for (var i = 0; i &lt; allElements.length; i++) {
	        var testElement = allElements[i];
	        if (testElement.value &amp;&amp; testElement.value === expectedValue) {
	            return testElement;
	        }
	    }
	    return null;
	};
	</pre>
	</blockquote>
	<p><strong>user-extensions.js</strong></p>
	<blockquote>
	<p>By default, Selenium looks for a file called &quot;user-extensions.js&quot;, and loads the javascript code found in that file. This file provides a convenient location for adding features to Selenium, without needing to modify the core Selenium sources.</p>
	<p>In the standard distibution, this file does not exist. Users can create this file and place their extension code in this common location, removing the need to modify the Selenium sources, and hopefully assisting with the upgrade process.</p>
	</blockquote>
	</div>
</xsl:template>

<xsl:template match="top">
	<xsl:apply-templates />
</xsl:template>

<xsl:template match="function" mode="check">
	<dt><strong>
		<xsl:call-template name="search-and-replace">
			<xsl:with-param name="input">&amp;nbsp;<xsl:value-of select="@name" /></xsl:with-param>
			<xsl:with-param name="search-string">&amp;nbsp;get</xsl:with-param>
			<xsl:with-param name="replace-string">assert</xsl:with-param>
		</xsl:call-template>
		
		(
			<xsl:apply-templates select="param" mode="declaration-check"/>
			pattern
		)
		/
			<xsl:call-template name="search-and-replace">
			<xsl:with-param name="input">&amp;nbsp;<xsl:value-of select="@name" /></xsl:with-param>
			<xsl:with-param name="search-string">&amp;nbsp;get</xsl:with-param>
			<xsl:with-param name="replace-string">assertNot</xsl:with-param>
		</xsl:call-template>
		
		(
			<xsl:apply-templates select="param" mode="declaration-check"/>
			pattern
		)
	</strong></dt>
	<dd>
		Asserts that the specified text pattern does (or does not) match the value returned by
		<xsl:value-of select="@name" />
		which:
		<xsl:apply-templates select="comment" />
		<p>Arguments:</p>
		<ul>
			<xsl:apply-templates select="param" mode="comment" />
			<li>pattern - a <a href="#patterns">pattern</a> to match with the retrieved result</li>
		</ul>
	</dd>
	<br/>
</xsl:template>

<xsl:template match="function" mode="action">
	<dt><strong>
		<xsl:value-of select="@name" />
		(
			<xsl:apply-templates select="param" mode="declaration-action"/>
		)
	</strong></dt>
	<dd>
		<xsl:apply-templates select="comment" />
		<p>Arguments:</p>
		<ul>
			<xsl:apply-templates select="param" mode="comment" />
		</ul>
	</dd>
	<br/>
</xsl:template>

<xsl:template match="param" mode="declaration-action">
	<xsl:value-of select="@name" />
	<xsl:if test="position() != last()">
		<xsl:text>,</xsl:text>
	</xsl:if>
</xsl:template>

<xsl:template match="param" mode="declaration-check">
	<xsl:value-of select="@name" />,
</xsl:template>

<xsl:template match="param" mode="comment">
	<li>
		<xsl:value-of select="@name" />
		<xsl:text> - </xsl:text>
		<xsl:apply-templates/>
	</li>
</xsl:template>

<xsl:template match="node()|@*" >
   <xsl:copy>
        <xsl:apply-templates select="node()|@*" />
   </xsl:copy>
</xsl:template> 

<xsl:template name="search-and-replace">
     <xsl:param name="input"/>
     <xsl:param name="search-string"/>
     <xsl:param name="replace-string"/>
     <xsl:choose>
          <!-- See if the input contains the search string -->
          <xsl:when test="$search-string and 
                           contains($input,$search-string)">
          <!-- If so, then concatenate the substring before the search
          string to the replacement string and to the result of
          recursively applying this template to the remaining substring.
          -->
               <xsl:value-of 
                    select="substring-before($input,$search-string)"/>
               <xsl:value-of select="$replace-string"/>
               <xsl:call-template name="search-and-replace">
                    <xsl:with-param name="input"
                    select="substring-after($input,$search-string)"/>
                    <xsl:with-param name="search-string" 
                    select="$search-string"/>
                    <xsl:with-param name="replace-string" 
                        select="$replace-string"/>
               </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
               <!-- There are no more occurrences of the search string so 
               just return the current input string -->
               <xsl:value-of select="$input"/>
          </xsl:otherwise>
     </xsl:choose>
</xsl:template>

</xsl:stylesheet>